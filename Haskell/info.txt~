Start by typing ghci in the prompt
By default, the prompt is Prelude.
If I want it to be gchi -as the book- type
  :set prompt "ghci> "
If I want to change its default to start it directly,
create a .ghci file in the home folder and its content:
  :set prompt "ghci> "
_______________________________________________________

BASIC CONCEPTS:

- Laziness, etc
- let is a keyword used to define a name in GHCi. Entering "let a = 1"
  in GHCi is equivalent to writing a = 1 in a script, then loading it with :l
_______________________________________________________

FUNCTIONS:

- functionName parameter = body
- The order the funcitons get declared in a .hs file doesn't matter.
- Defined functions can call each other.
- An if in Haskell is not a statement, it is a expression:
  in order to be executed, requires an else.
- The apostrophe (') at the end of a function name doesn't have 
  any special meaning in Haskell's syntax, which means its a valid
  character top use in a function name. It is ude to denote either
  a strict version of a function (i.e. that it isn't lazy) or a
  slightly modified version of a function or a variable with a
  similar name.
- Functions cannot start with capital Letter
- A declaration such as "conanO'Brien" at "baby.hs" is not a function
  since it doesn't take any parameters.It is a definition or a name, hence 
  "conanO'Brien" and its content can be used interchangeably.

_______________________________________________________

LISTS:

- Are homogenous: they store elements of the same type.
- Are surrounded by square brackets and the list values are separated by commas:
  (e.g., [1, 2, 3, 8, 9])
- The use of the let keyword is really helfpulf when working with lists (see BASIC CONCEPTS)
- CONCATENION: done with ++. All parameters (left and right) have to be of the same type:
  i.e., if you just one to ad a number to a list through ++ you cannot treat it like a : and
  directly put the "number : [list]]", you actually have to treat the single number as a list. 
- We can use list functions on strings since "hey" is actually the same as the list
  ['h','e','y'], and this will appear as "hey" as a whole, not as in number lists
  -with commas separating each value.
- CONS OPERATOR: ":" it adds a SINGLE value  -of the same category, not exact same type- into
  the beginning of a list. It is really handy when working with huge lists: the ++ has
  to walk through the whole list, while : doesn't since it adds the value at the beginning.
- [1,2,3,4] is exactly the same as 1:2:3:4:[]. Why? "[]" prepend into "4", equalling "[4]".
  Then, "3" prepends into "[4]", and so on.
- [] is an empty list.
- [[]] is a list that contains one empty list.
- [[],[],[]] is a list that contains three empty lists.
- Accessing lists elements: through the !! operator. THe indicces start at 0.
- Lists can contain lists as elements, and lists can contain lists tat contain lists, and so on.
- Comparing lists (<, >, <=, >=). Both lists have to be of the same type. It compares them from
  left to right, one number at a time, and once differing numbers are found, a conclusion is made
  (true, false). A nonempty list is ALWAYS considered to be greater than an empty list.
  
LIST FUNCTIONS:
- head [1, 2, 3]. Returns 1 (the list' head, or first element).
- tail [1, 2, 3]. Returns [2, 3] (the whole list' content exceptuating the head).
- last [1, 2, 3]. Returns 3 (the list' last element).
- init [1, 2, 3]. Returns [1, 2], it is, everything except the last element.
BE CAREFUL WHEN USING head, tail, last, int , AN NEVER USE THEM ON EMPTY LISTS: that's an error
that isn't caughtat compile time, so it will bring problems if we don't detect them.
- lenght [1, 2, 3]. Returns 3, the list' lenght. STARTS AT 1, not at 0.
- null [1,2,3]. Returns "false", since the list != null. Hence, "null []" returns "false".
- reverse [1,2,3]. Returns [3,2,1], as it name states.